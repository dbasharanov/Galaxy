
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - materials</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #202020;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="http://threejs.org/build/three.min.js"></script>

		<script src="http://threejs.org/examples/js/renderers/Projector.js"></script>
		<script src="http://threejs.org/examples/js/renderers/CanvasRenderer.js"></script>
		<script src='http://threejs.org/examples/js/controls/TrackballControls.js'></script>
		<script src="http://threejs.org/examples/js/libs/stats.min.js"></script>

		<script>

			var camera, controls, scene, renderer;

			var renderer, objects;
			var pointLight;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 500;

				controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', render );



				container = document.createElement('div');
				document.body.appendChild(container);

				scene = new THREE.Scene();

				// Grid

				var size = 500, step = 100;
				var geometry = new THREE.Geometry();

				for ( var i = - size; i <= size; i += step ) {

					geometry.vertices.push( new THREE.Vector3( - size, - 120, i ) );
					geometry.vertices.push( new THREE.Vector3(   size, - 120, i ) );

					geometry.vertices.push( new THREE.Vector3( i, - 120, - size ) );
					geometry.vertices.push( new THREE.Vector3( i, - 120,   size ) );

				}

				var material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 0.2 } );

				var line = new THREE.Line( geometry, material, THREE.LinePieces );
				scene.add( line );

				// Spheres

				var geometry = new THREE.SphereGeometry( 100, 14, 7 );

				var materials = [

					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/mercury.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/venus.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/earth.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/mars.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/jupiter.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/saturn.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/uranus.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/neptune.jpg' ) } ),
					new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'textures/pluto.jpg' ) } ),

				];

				for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {

					var face = geometry.faces[ i ];
					if ( Math.random() > 0.5 ) face.materialIndex = Math.floor( Math.random() * materials.length );

				}

				materials.push( new THREE.MeshFaceMaterial( materials ) );

				objects = [];

				var position = 0;
				
				// mercury
				var mercury = new THREE.Mesh( new THREE.SphereGeometry( 3.8, 14, 7 ), materials[ 0 ] );
				mercury.position.x = 3.8;
				position +=3.8;
				//mercury.position.z = Math.floor( 1 / 5 ) * 200 - 200;

				mercury.rotation.x = Math.random() * 200 - 100;
				mercury.rotation.y = Math	.random() * 200 - 100;
				mercury.rotation.z = Math.random() * 200 - 100;

				objects.push( mercury );
				scene.add( mercury );

				// venus
				var venus   = new THREE.Mesh( new THREE.SphereGeometry( 9.5, 14, 7 ), materials[ 1 ] );
				venus.position.x = 7.2;
				//venus.position.z = Math.floor( 2 / 5 ) * 200 - 200;

				venus.rotation.x = Math.random() * 200 - 100;
				venus.rotation.y = Math.random() * 200 - 100;
				venus.rotation.z = Math.random() * 200 - 100;

				objects.push( venus );
				scene.add( venus );

				// earth
				var earth   = new THREE.Mesh( new THREE.SphereGeometry( 10, 14, 7 ), materials[ 2 ] );
				earth.position.x = 10;
				//earth.position.z = Math.floor( 3 / 5 ) * 200 - 200;

				earth.rotation.x = Math.random() * 200 - 100;
				earth.rotation.y = Math.random() * 200 - 100;
				earth.rotation.z = Math.random() * 200 - 100;

				objects.push( earth );
				scene.add( earth );

				// mars
				var mars   = new THREE.Mesh( new THREE.SphereGeometry( 5.3, 14, 7 ), materials[ 3 ] );
				mars.position.x = 15;
				//mars.position.z = Math.floor( 4 / 5 ) * 200 - 200;

				mars.rotation.x = Math.random() * 200 - 100;
				mars.rotation.y = Math.random() * 200 - 100;
				mars.rotation.z = Math.random() * 200 - 100;

				objects.push( mars );	
				scene.add( mars );	

				// jupiter
				var jupiter   = new THREE.Mesh( new THREE.SphereGeometry( 112, 14, 7 ), materials[ 4 ] );
				jupiter.position.x = 52;
				//jupiter.position.z = Math.floor( 5 / 5 ) * 200 - 200;

				jupiter.rotation.x = Math.random() * 200 - 100;
				jupiter.rotation.y = Math.random() * 200 - 100;
				jupiter.rotation.z = Math.random() * 200 - 100;

				objects.push( jupiter );
				scene.add( jupiter );			

				// saturn
				var saturn   = new THREE.Mesh( new THREE.SphereGeometry( 94.1, 14, 7 ), materials[ 5 ] );
				saturn.position.x = 95;
				//saturn.position.z = Math.floor( 6 / 5 ) * 200 - 200;

				saturn.rotation.x = Math.random() * 200 - 100;
				saturn.rotation.y = Math.random() * 200 - 100;
				saturn.rotation.z = Math.random() * 200 - 100;

				objects.push( saturn );
				scene.add( saturn );

				// uranus
				var uranus   = new THREE.Mesh( new THREE.SphereGeometry( 39.8, 14, 7 ), materials[ 6 ] );
				uranus.position.x = 192;
				//uranus.position.z = Math.floor( 7 / 5 ) * 200 - 200;

				uranus.rotation.x = Math.random() * 200 - 100;
				uranus.rotation.y = Math.random() * 200 - 100;
				uranus.rotation.z = Math.random() * 200 - 100;

				objects.push( uranus );
				scene.add( uranus );

				// neptune
				var neptune   = new THREE.Mesh( new THREE.SphereGeometry( 38.1, 14, 7 ), materials[ 7 ] );
				neptune.position.x = 300;
				//neptune.position.z = Math.floor( 8 / 5 ) * 200 - 200;

				neptune.rotation.x = Math.random() * 200 - 100;
				neptune.rotation.y = Math.random() * 200 - 100;
				neptune.rotation.z = Math.random() * 200 - 100;

				objects.push( neptune );
				scene.add( neptune );


				// pluto
				var pluto   = new THREE.Mesh( new THREE.SphereGeometry( 2.4, 14, 7 ), materials[ 8 ] );
				pluto.position.x = 395;
				//pluto.position.z = Math.floor( 3 / 5 ) * 200 - 200;

				pluto.rotation.x = Math.random() * 200 - 100;
				pluto.rotation.y = Math.random() * 200 - 100;
				pluto.rotation.z = Math.random() * 200 - 100;

				objects.push( pluto );
				scene.add( pluto );


				var PI2 = Math.PI * 2;
				var program = function ( context ) {

					context.beginPath();
					context.arc( 0, 0, 0.5, 0, PI2, true );
					context.fill();

				}

				// Lights

				scene.add( new THREE.AmbientLight( Math.random() * 0x202020 ) );

				var directionalLight = new THREE.DirectionalLight( Math.random() * 0xffffff );
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add( directionalLight );

				pointLight = new THREE.PointLight( 0xffffff, 1 );
				scene.add( pointLight );

				var sprite = new THREE.Sprite( new THREE.SpriteCanvasMaterial( { color: 0xffffff, program: program } ) );
				sprite.scale.set( 8, 8, 8 );
				pointLight.add( sprite );

				renderer = new THREE.CanvasRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				var debugCanvas = document.createElement( 'canvas' );
				debugCanvas.width = 512;
				debugCanvas.height = 512;
				debugCanvas.style.position = 'absolute';
				debugCanvas.style.top = '0px';
				debugCanvas.style.left = '0px';

				container.appendChild( debugCanvas );

				debugContext = debugCanvas.getContext( '2d' );
				debugContext.setTransform( 1, 0, 0, 1, 256, 256 );
				debugContext.strokeStyle = '#000000';

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild(stats.domElement);

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				controls.handleResize();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function loadImage( path ) {

				var image = document.createElement( 'img' );
				var texture = new THREE.Texture( image, THREE.UVMapping )

				image.onload = function () { texture.needsUpdate = true; };
				image.src = path;

				return texture;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				controls.update();
				stats.update();

			}

			function render() {

				var timer = Date.now() * 0.0001;

				//camera.position.x = Math.cos( timer ) * 1000;
				//camera.position.z = Math.sin( timer ) * 1000;
				//camera.lookAt( scene.position );

				for ( var i = 0, l = objects.length; i < l; i++ ) {

					var object = objects[ i ];

					//object.rotation.x += 0.01;
					object.rotation.y += 0.05;

				}

				pointLight.position.x = Math.sin( timer * 7 ) * 300;
				pointLight.position.y = Math.cos( timer * 5 ) * 400;
				pointLight.position.z = Math.cos( timer * 3 ) * 300;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
